---
layout: post
title: "Bit Manipulation[0]"
description: ""
category: Programming
tags: [Bit Manipulation]
---
Grab from [Matrix67](http://www.matrix67.com/blog/archives/263)
###===1. and运算 ===
and运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.  
###=== 2. or运算 ===
  or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
###=== 3. xor运算 ===
  xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。<br>
<br>
  xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为密钥。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520，于是她就明白了我的企图。<br>
<br>
下面我们看另外一个东西。定义两个符号#和@（我怎么找不到那个圈里有个叉的字符），这两个符号互为逆运算，也就是说```(x # y) @ y = x```。现在依次执行下面三条命令，结果是什么？
{% highlight cpp %}
	x <- x # y
	y <- x @ y
	x <- x @ y
{% endhighlight %}
执行了第一句后x变成了x # y。那么第二句实质就是y <- x # y @ y，由于#和@互为逆运算，那么此时的y变成了原来的x。第三句中x实际上被赋值为(x # y) @ x，如果#运算具有交换律，那么赋值后x就变成最初的y了。这三句话的结果是，x和y的位置互换了。<br>
<br>
  加法和减法互为逆运算，并且加法满足交换律。把#换成+，把@换成-，我们可以写出一个不需要临时变量的swap过程(Pascal)。
{% highlight cpp %}
	procedure swap(var a,b:longint);
	begin
	   a:=a + b;
	   b:=a - b;
	   a:=a - b;
	end;
{% endhighlight %}
  好了，刚才不是说xor的逆运算是它本身吗？于是我们就有了一个看起来非常诡异的swap过程：
{% highlight cpp %}
	procedure swap(var a,b:longint);
	begin
	   a:=a xor b;
	   b:=a xor b;
	   a:=a xor b;
	end;
{% endhighlight %}
###=== 4. not运算 ===
  not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。下面的两个程序（仅语言不同）均返回65435。
{% highlight cpp %}
	var
	   a:word;
	begin
	   a:=100;
	   a:=not a;
	   writeln(a);
	end.

	#include <stdio.h>
	int main()
	{
	    unsigned short a=100;
	    a = ~a;
	    printf( "%d\n", a );    
	    return 0;
	}
{% endhighlight %}
  如果not的对象是有符号的整数，情况就不一样了，稍后我们会在“整数类型的储存”小节中提到。

###=== 5. shl运算 ===
  a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。<br>
<br>
  通常认为a shl 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替.<br>
<br>
  定义一些常量可能会用到shl运算。你可以方便地用1 shl 16 - 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用shl来定义Max_N等常量。

###=== 6. shr运算 ===
  和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用shr 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。

